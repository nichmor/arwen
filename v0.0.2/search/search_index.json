{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#1-introduction","title":"1. Introduction","text":""},{"location":"#what-is-arwen","title":"What is <code>arwen</code>?","text":"<p><code>arwen</code> is a command-line utility and Rust library designed to modify executable files and shared libraries.</p> <p>Specifically, it targets the ELF format (commonly used on Linux, BSD, and other Unix-like systems) and the Mach-O format (used on macOS and iOS).</p> <p>It allows you to inspect and rewrite various properties within these files that influence how they load and link with other libraries at runtime.</p> <p>Think of <code>arwen</code> as a modern, unified, Rust-based alternative to the widely-used <code>patchelf</code> (for ELF files) and <code>install_name_tool</code> (for Mach-O files). It combines the core functionalities of both into a single tool.</p>"},{"location":"#quick-installation","title":"Quick Installation:","text":"<p>You can install <code>arwen</code> using Cargo, the Rust package manager:</p> <pre><code>cargo install arwen\n</code></pre>"},{"location":"#why-use-arwen","title":"Why use <code>arwen</code>?","text":"<p>Modifying these executable properties is often necessary for:</p> <ul> <li>Application Packaging: Ensuring your application can find its bundled libraries regardless of where it's installed.</li> <li>Relocation: Making software work correctly after being moved to a different path.</li> <li>Fixing Linkage Issues: Correcting paths embedded during the build process that don't match the target environment.</li> </ul>"},{"location":"#core-features","title":"Core Features","text":""},{"location":"#for-elf-files","title":"For ELF files:","text":"<ul> <li>View and change the dynamic library search path (<code>RPATH</code> / <code>RUNPATH</code>).</li> <li>View and change the dynamic linker/interpreter path.</li> <li>View, add, remove, or replace required shared library dependencies (<code>DT_NEEDED</code> entries).</li> </ul>"},{"location":"#for-mach-o-files","title":"For Mach-O files:","text":"<ul> <li>View and change the library's identity (<code>Install Name</code> / <code>LC_ID_DYLIB</code>).</li> <li>View and change the paths to dependent dynamic libraries (<code>LC_LOAD_DYLIB</code>, etc.).</li> <li>View, add, or delete runtime search paths (<code>LC_RPATH</code>).</li> </ul>"},{"location":"#general-features","title":"General Features:","text":"<ul> <li>Cross-Platform: Implemented in Rust, aiming for reliability and ease of building across different platforms.</li> <li>Library Usage: Can be used directly within your Rust projects to programmatically inspect or patch binaries.</li> <li>Python Bindings: Provides a Python interface for easier integration into Python-based workflows.</li> </ul> <p>Resources:</p> <ul> <li>Source Code Repository: <code>[text](https://github.com/nichmor/arwen)</code></li> <li>Issue Tracker: <code>[https://github.com/nichmor/arwen/issues]</code></li> <li>License: <code>[https://github.com/nichmor/arwen/blob/main/LICENSE]</code></li> </ul>"},{"location":"why_patch/","title":"Why patching binaries?","text":""},{"location":"why_patch/#why-patch-executables-and-libraries","title":"Why Patch Executables and Libraries?","text":"<p>Modern operating systems rely heavily on dynamic linking.</p> <p>Instead of embedding the code for every function an application needs directly into the executable file (which is called static linking and results in very large files), dynamic linking allows executables to use shared libraries (<code>.so</code> files on Linux/ELF, <code>.dylib</code> files on macOS/Mach-O) that are loaded into memory only when the program runs.</p> <p>This saves disk space and memory, and allows libraries to be updated independently of the applications using them.</p> <p>Note</p> <p>About Linking Types:</p> <p>Static Linking: Copies all necessary library code directly into the final executable during compilation. This creates larger, self-contained files. If a library needs an update, any application using it must be recompiled.</p> <p>Dynamic Linking: The executable only stores references (like names or paths) to external shared library files. The operating system's dynamic linker loads these libraries at runtime. This leads to smaller executables, allows libraries to be shared in memory by multiple applications, and enables independent library updates (though this can sometimes lead to versioning issues).</p>"},{"location":"why_patch/#the-problem-finding-libraries-at-runtime","title":"The Problem: Finding Libraries at Runtime","text":"<p>When you run an executable that uses dynamic linking, the operating system's dynamic linker (or loader) has a crucial job: it must find and load all the required shared libraries mentioned by the executable. How does it find them? It typically searches in a specific order, which might include:</p> <ol> <li>Paths explicitly encoded within the executable itself (RPATH, RUNPATH for ELF; Install Names, RPATH using <code>@rpath</code> for Mach-O).</li> <li>Paths specified by environment variables (e.g., <code>LD_LIBRARY_PATH</code> on Linux, <code>DYLD_LIBRARY_PATH</code> on macOS - often discouraged for general use).</li> <li>Default system library directories (e.g., <code>/lib</code>, <code>/usr/lib</code>, <code>/usr/local/lib</code>).</li> </ol> <p>The challenge arises because the assumptions made during compilation about where libraries will be located might not hold true when the application is actually deployed or run. Hardcoded absolute paths might be wrong, default system paths might not contain the right library versions, and relative paths need careful management.</p>"},{"location":"why_patch/#a-small-practical-example-for-elf-file","title":"A small practical example for ELF file","text":"<p>Let's say you run an executable program located at <code>/usr/bin/my_app</code>. This program requires a shared library called <code>libdata.so.1</code>.</p> <p>When you execute <code>/usr/bin/my_app</code>, the Linux kernel loads the <code>my_app</code> executable into memory. It sees from the executable's header that it needs a dynamic linker, typically <code>/lib64/ld-linux-x86-64.so.2</code> (on a 64-bit system). The kernel loads this dynamic linker and passes control to it.</p> <p>Dynamic linker (our <code>ld-linux.so.2</code>) inspects <code>my_app</code>'s internal structure (specifically the <code>.dynamic</code> section) and finds an entry indicating it needs <code>libdata.so.1</code>.</p> <p>It starts searching for the file <code>libdata.so.1</code> in a specific order (this is simplified list):</p> <ul> <li><code>DT_RUNPATH</code>: It checks if <code>my_app</code> has a <code>DT_RUNPATH</code> entry.   Let's imagine <code>my_app</code> was patched to have <code>DT_RUNPATH=$ORIGIN/../lib</code>. <code>$ORIGIN</code> means \"the directory containing the executable\", so the linker looks for <code>/usr/bin/../lib/libdata.so.1</code> (which resolves to <code>/usr/lib/libdata.so.1</code>). If it exists, the linker proceeds to step 4.</li> </ul> <ul> <li><code>LD_LIBRARY_PATH</code> Check: If the library wasn't found via RUNPATH (or if RUNPATH doesn't exist), the linker checks the <code>LD_LIBRARY_PATH</code> environment variable. If you had run the app like <code>LD_LIBRARY_PATH=/opt/custom_libs /usr/bin/my_app</code>, the linker would look for <code>/opt/custom_libs/libdata.so.1</code>. If found here, it uses this one and skips the <code>RPATH</code> check below.</li> </ul> <ul> <li><code>DT_RPATH</code>: If not found yet, and if my_app has an <code>RPATH</code> entry (which is different from <code>RUNPATH</code>), the linker checks there. For example, if <code>RPATH=/usr/local/special_libs</code>, it looks for <code>/usr/local/special_libs/libdata.so.1</code>.</li> </ul> <ul> <li><code>System Cache/Paths</code>: If still not found, the linker consults the system library cache (usually <code>/etc/ld.so.cache</code>, built from <code>/etc/ld.so.conf</code>) and then checks standard default paths like <code>/lib, /usr/lib, /lib64, /usr/lib64</code>. It looks for <code>/lib/libdata.so.1, /usr/lib/libdata.so.1</code>, etc.</li> </ul> <ul> <li><code>Loading</code>: This is the last part. Once <code>libdata.so.1</code> is found the dynamic linker maps its code and data segments into the memory space of the <code>my_app</code> process.</li> </ul> <p>This is where patching becomes essential. Tools like <code>arwen</code> allow you to modify the information embedded within the executable after it has been compiled and linked, telling the dynamic linker where to find the necessary libraries in the actual runtime environment.</p> <p>Common Scenarios Requiring Patching:</p> <p>Here are some frequent situations where you'll need to patch executables or libraries using a tool like <code>arwen</code>:</p> <ul> <li>Relocation / Non-Standard Installs:     Software is installed in a non-standard location (e.g., <code>/opt/myapp</code>, <code>/home/user/bin</code>) instead of system paths like <code>/usr/bin</code>. Binaries might have been compiled assuming standard library locations.     Patch the binaries to add the application's own library directory (e.g., <code>/opt/myapp/lib</code>) to their runtime search path (<code>RPATH</code>/<code>RUNPATH</code> or Mach-O <code>LC_RPATH</code>).</li> </ul> <ul> <li>Cross-Compilation:     When building software for a different architecture or operating system, the embedded paths might reflect the host system's layout, not the target's. Patch the resulting binaries to use paths appropriate for the target system.</li> </ul>"},{"location":"patching/elf/","title":"ELF","text":""},{"location":"patching/elf/#elf-executable-and-linkable-format","title":"ELF (Executable and Linkable Format)","text":"<p><code>ELF</code> is the standard binary format used on Linux, BSD variants, Solaris, and many other Unix-like operating systems for <code>executables</code>, <code>shared libraries (.so files)</code>, <code>object code</code>, and <code>core dumps</code>.</p> <ul> <li>Executables: These are files containing machine code instructions that the operating system can load directly into memory and run as a program. They are the result of compiling and linking source code. On Linux, common executables like <code>/bin/bash</code> or <code>/usr/bin/grep</code> are typically in ELF format.</li> </ul> <ul> <li>Shared Libraries (.so files): Standing for <code>\"Shared Object\"</code>, these files contain compiled code and data (functions, variables) designed to be used by multiple executable programs at the same time while they are running <code>(this is dynamic linking)</code>. Instead of each program having its own copy of the library code, they share a single copy loaded in memory. Examples include <code>libc.so.6</code> (the standard C library) or <code>libssl.so</code> (for SSL/TLS functions).</li> </ul> <ul> <li>Object Code (.o files): This is the intermediate output produced by a compiler when it translates source code (like <code>.c</code> or <code>.rs</code> files) into machine code for a specific architecture. Object files aren't runnable on their own. They contain the compiled code and data but also information needed by the linker to combine them with other object files and libraries to create a final executable or shared library.</li> </ul> <ul> <li>Core Dumps: This is a file created by the operating system when a program crashes or terminates unexpectedly. It contains a snapshot of the program's state at the time of the crash, including its memory contents (the \"core\") and often CPU register values. Developers use core dump files with debuggers (like <code>gdb</code>) to perform post-mortem analysis and figure out why the program failed.</li> </ul>"},{"location":"patching/elf/#elf-file-structure-overview","title":"ELF File Structure Overview","text":"<ul> <li>ELF Header: Always located at the very beginning of the file (offset 0).</li> </ul> <ul> <li>Program Header Table (PHT): Optional, but present in executables and shared libraries. Describes segments used for loading the file into memory. Its location and size are specified in the ELF Header.</li> </ul> <ul> <li>Sections: Contain the actual code, data, symbol tables, string tables, and linking information. Their locations and sizes are described by the <code>Section Header Table</code>.</li> </ul> <ul> <li>Section Header Table (SHT): Present except sometimes in stripped executables. Describes the file's sections. Its location and size are specified in the ELF Header, often placed near the end of the file.</li> </ul> <p>A simple ELF file structure looks like this:</p> <pre><code>+---------------------+\n| ELF Header          |  (File Offset 0)\n+---------------------+\n| Program Header Table|  (Offset specified in ELF Header)\n| (Optional)          |\n+---------------------+\n|                     |\n| Segment 1 / Section |  (e.g., Code .text)\n|                     |\n+---------------------+\n|                     |\n| Segment 2 / Section |  (e.g., Data .data, .bss)\n|                     |\n+---------------------+\n| ...                 |  (Other segments/sections like .dynamic)\n+---------------------+\n|                     |\n| Section Header Table|  (Offset specified in ELF Header, often near end)\n| (Optional)          |\n+---------------------+\n</code></pre> <p>Note</p> <p>Sections are often contained within Segments.</p> <p>The PHT describes the file from a loading/memory perspective (Segments), while the SHT describes it from a linking/content perspective (Sections).</p>"},{"location":"patching/elf/#more-detailed-view-of-the-components","title":"More detailed view of the components","text":"<ul> <li><code>1. ELF Header (Elf64_Ehdr / Elf32_Ehdr)</code><ul> <li>Location: Start of the file (offset 0).</li> <li>Purpose: Identifies the file as ELF and provides essential metadata and pointers.</li> <li>Key Fields:<ul> <li><code>e_ident</code>: Magic number (<code>\\x7fELF</code>) and other info (class 32/64-bit, data encoding, ABI version).</li> <li><code>e_type</code>: File type (e.g., <code>ET_EXEC</code> for executable, <code>ET_DYN</code> for shared library/position-independent executable, <code>ET_REL</code> for relocatable object file).</li> <li><code>e_machine</code>: Target architecture (e.g., <code>EM_X86_64</code>, <code>EM_AARCH64</code>).</li> <li><code>e_version</code>: ELF version (usually 1).</li> <li><code>e_entry</code>: Virtual memory address of the program's entry point (where execution begins).</li> <li><code>e_phoff</code>: File offset to the start of the Program Header Table.</li> <li><code>e_shoff</code>: File offset to the start of the Section Header Table.</li> <li><code>e_flags</code>: Processor-specific flags.</li> <li><code>e_ehsize</code>: Size of this ELF header.</li> <li><code>e_phentsize</code>: Size of a single entry in the Program Header Table.</li> <li><code>e_phnum</code>: Number of entries in the Program Header Table.</li> <li><code>e_shentsize</code>: Size of a single entry in the Section Header Table.</li> <li><code>e_shnum</code>: Number of entries in the Section Header Table.</li> <li><code>e_shstrndx</code>: Section header table index of the section containing section names.</li> </ul> </li> </ul> </li> </ul> <ul> <li>2. Program Header Table (PHT)<ul> <li>Location: At the file offset specified by <code>e_phoff</code> in the ELF Header. It's an array of <code>e_phnum</code> entries, each <code>e_phentsize</code> bytes long.</li> <li>Purpose: Describes segments \u2013 contiguous chunks of the file that need to be mapped into memory by the system loader when creating a process image. This is the \"execution view\" of the file.</li> <li><code>Key Entry Types (p_type):</code><ul> <li><code>PT_LOAD</code>: Describes a loadable segment (e.g., code, data). Specifies file offset (<code>p_offset</code>), virtual address (<code>p_vaddr</code>), physical address (<code>p_paddr</code> - often ignored), file size (<code>p_filesz</code>), memory size (<code>p_memsz</code> - can be larger for <code>.bss</code>), and permissions (<code>p_flags</code> - Read/Write/Execute).</li> <li><code>PT_DYNAMIC</code>: Points to the segment containing dynamic linking information (the <code>.dynamic</code> section). Specifies offset (<code>p_offset</code>) and size (<code>p_filesz</code>). Essential for executables/libraries using dynamic linking.</li> <li><code>PT_INTERP</code>: Points to a null-terminated string specifying the path of the program interpreter (dynamic linker, e.g., <code>/lib64/ld-linux-x86-64.so.2</code>).</li> <li>Other types exist for notes (<code>PT_NOTE</code>), TLS (<code>PT_TLS</code>), etc.</li> </ul> </li> </ul> </li> </ul> <ul> <li>3. Sections<ul> <li>Location: Scattered throughout the file, as defined by the Section Header Table.</li> <li>Purpose: Hold the actual content: compiled code, data, symbol tables, string tables, relocation information, dynamic linking structures, debugging info, etc. Sections represent the \"linking view\" of the file.</li> <li>Common Sections:</li> <li><code>.text</code>: Executable code.<ul> <li><code>.data</code>: Initialized data (global/static variables with initial values).</li> <li><code>.bss</code>: Uninitialized data (global/static variables without explicit initial values; occupies no file space but reserves memory space).</li> <li><code>.rodata</code>: Read-only data (constants, string literals).</li> <li><code>.symtab</code>: Symbol table (for linking/debugging).</li> <li><code>.strtab</code>: String table for <code>.symtab</code>.</li> <li><code>.shstrtab</code>: String table for section names themselves.</li> <li><code>.dynamic</code>: Holds the array of dynamic linking tags (see below).</li> <li><code>.dynsym</code>: Minimal symbol table needed for dynamic linking.</li> <li><code>.dynstr</code>: String table for <code>.dynsym</code> and <code>.dynamic</code> entries requiring strings (like library names in <code>DT_NEEDED</code>).</li> <li><code>.interp</code>: Contains the path string for the program interpreter (pointed to by <code>PT_INTERP</code>).</li> </ul> </li> </ul> </li> </ul> <ul> <li>4. Section Header Table (SHT)<ul> <li>Location: At the file offset specified by <code>e_shoff</code> in the ELF Header. An array of <code>e_shnum</code> entries, each <code>e_shentsize</code> bytes long.</li> <li>Purpose: Describes each section in the file. Essential for linkers and debuggers, less so for the runtime loader (which uses the PHT).</li> <li><code>Key Fields in an Entry (Elf64_Shdr / Elf32_Shdr):</code><ul> <li><code>sh_name</code>: Offset into the <code>.shstrtab</code> section giving the section's name.</li> <li><code>sh_type</code>: Section type (e.g., <code>SHT_PROGBITS</code> for code/data, <code>SHT_SYMTAB</code> for symbols, <code>SHT_STRTAB</code> for strings, <code>SHT_NOBITS</code> for <code>.bss</code>, <code>SHT_DYNAMIC</code> for dynamic tags).</li> <li><code>sh_flags</code>: Attributes like <code>SHF_WRITE</code>, <code>SHF_ALLOC</code> (occupies memory), <code>SHF_EXECINSTR</code> (executable code).</li> <li><code>sh_addr</code>: Virtual memory address if the section is loaded.</li> <li><code>sh_offset</code>: File offset of the section's start.</li> <li><code>sh_size</code>: Size of the section in the file.</li> <li><code>sh_link</code>, <code>sh_info</code>: Interpretation depends on section type (e.g., for <code>.dynamic</code>, <code>sh_link</code> points to the string table <code>.dynstr</code>).</li> <li><code>sh_addralign</code>: Required alignment.</li> <li><code>sh_entsize</code>: Size of entries if the section holds a table (like symbol table).</li> </ul> </li> </ul> </li> </ul>"},{"location":"patching/elf/#dynamic-linking","title":"Dynamic Linking","text":"<p>For dynamic linking, the crucial parts are:</p> <ol> <li>The <code>PT_INTERP</code> program header entry (and the <code>.interp</code> section it points to) tells the kernel which dynamic linker to execute.</li> <li>The <code>PT_DYNAMIC</code> program header entry points to the segment containing the <code>.dynamic</code> section.</li> <li>The <code>.dynamic</code> section contains the array of tags and values that drive the dynamic linker. <code>arwen</code> modifies values associated with specific tags within this section (or the string table <code>.dynstr</code> they point to):     * <code>DT_INTERP</code>: (Tag only, value points into <code>.dynstr</code>) Path to the dynamic linker. Modifying the string in <code>.dynstr</code> changes the interpreter.     * <code>DT_NEEDED</code>: (Value points into <code>.dynstr</code>) Name of a required library. Modifying the string in <code>.dynstr</code> changes the dependency. <code>arwen</code> can also add/remove entries in the <code>.dynamic</code> array itself.     * <code>DT_RPATH</code> / <code>DT_RUNPATH</code>: (Value points into <code>.dynstr</code>) Library search paths. Modifying the string in <code>.dynstr</code> changes these paths. Remember <code>$ORIGIN</code> is expanded by the linker to the directory of the object being processed.</li> </ol> <p>How the Dynamic Linker Uses This Information (Simplified version)</p> <p>The dynamic linker (<code>ld-linux.so.2</code> or similar), specified by <code>PT_INTERP</code> / <code>DT_INTERP</code>, reads the <code>.dynamic</code> section (found via <code>PT_DYNAMIC</code>). It processes <code>DT_NEEDED</code> entries to find required libraries, searching in paths derived from <code>DT_RUNPATH</code>, <code>LD_LIBRARY_PATH</code>, <code>DT_RPATH</code>, and system defaults, then loads them into memory (using their own ELF structures) and resolves symbols.</p> <p>Understanding this workflow, helps understanding how <code>arwen</code> modifies an RPATH or a needed library. It's mostly targeting specific entries within the <code>.dynamic</code> section or the associated <code>.dynstr</code> string table within the ELF file layout.</p>"},{"location":"patching/introduction/","title":"Introduction","text":"<p>To effectively use a tool like <code>arwen</code>, it helps to understand what you are actually modifying inside an executable file or shared library. Both <code>ELF (Executable and Linkable Format)</code> and <code>Mach-O (Mach Object)</code> are complex binary file formats that tell the operating system how to load and run code.</p> <p>This tutorial won't cover every detail of these formats but will focus on the specific parts relevant to dynamic linking and the common patching operations performed by <code>arwen</code>.</p>"},{"location":"patching/macho/","title":"Macho","text":""},{"location":"patching/macho/#understanding-mach-o-files-and-patching","title":"Understanding Mach-O Files and Patching","text":"<p>Mach-O (Mach Object) is the native binary file format used by Apple operating systems, including macOS, iOS, iPadOS, tvOS, and watchOS. It defines the structure for executables, dynamic libraries (<code>.dylib</code>), frameworks, bundles, and object files (<code>.o</code>). Understanding its structure is key to manipulating dependencies and runtime behavior, often necessary for application packaging and relocation.</p>"},{"location":"patching/macho/#mach-o-file-structure","title":"Mach-O File Structure","text":"<p>A Mach-O file is organized into three main regions:</p> <ul> <li>Mach Header: Located at the very beginning (offset 0). It identifies the file as Mach-O, specifies the target architecture (e.g., x86_64, arm64), the file type (executable, dylib, etc.), and most importantly, the number and total size of the Load Commands that follow.</li> <li>Load Commands: A list of variable-length commands immediately following the header. These commands act as instructions for the operating system's dynamic linker (<code>dyld</code>) and the kernel, dictating how to map the file into memory, what libraries are needed, where the main execution thread starts, symbol table locations, code signature details, and more.</li> <li>Data: The bulk of the file, containing the actual code and data, organized into segments and sections as specified by the Load Commands.</li> </ul> <p>Visual Layout</p> <pre><code>+---------------------+\n| Mach Header         | (File Offset 0)\n| (mach_header_64)    |\n+---------------------+\n| Load Command 1      | (Immediately follows Header)\n+---------------------+\n| Load Command 2      |\n+---------------------+\n| ...                 |\n+---------------------+\n| Load Command N      | (Total size = sizeofcmds from Header)\n+---------------------+\n|                     |\n| Data Region 1       | (e.g., __TEXT Segment: code sections)\n| (Segments/Sections) |\n+---------------------+\n|                     |\n| Data Region 2       | (e.g., __DATA Segment: data sections)\n|                     |\n+---------------------+\n| ...                 | (e.g., __LINKEDIT: symbol/string tables)\n+---------------------+\n</code></pre>"},{"location":"patching/macho/#load-commands-the-core-instructions","title":"Load Commands: The Core Instructions","text":"<p>The Load Commands region is central to Mach-O's functionality. <code>dyld</code> parses this list to understand how to prepare the binary for execution. Each command has a type (<code>cmd</code>) and size (<code>cmdsize</code>). Key types include:</p> <ul> <li><code>LC_SEGMENT_64</code> / <code>LC_SEGMENT</code>: Defines a segment (e.g., <code>__TEXT</code>, <code>__DATA</code>, <code>__LINKEDIT</code>) and its properties: file offset/size, virtual memory address/size, and permissions (read/write/execute). It also contains descriptions of the sections (like <code>__TEXT.__text</code>, <code>__DATA.__data</code>) within that segment.</li> <li><code>LC_ID_DYLIB</code>: Specifies the \"install name\" for a dynamic library. This is the canonical path identifying the library, used by other binaries when linking against it.</li> <li><code>LC_LOAD_DYLIB</code>: Defines a dependency on an external dynamic library, specifying the library's install name (the path to find it).</li> <li><code>LC_LOAD_WEAK_DYLIB</code>: Defines an optional library dependency.</li> <li><code>LC_REEXPORT_DYLIB</code>: Links against another library and re-exports its symbols.</li> <li><code>LC_RPATH</code>: Adds a path to the runtime search path list, used for resolving <code>@rpath</code> dependencies.</li> <li><code>LC_MAIN</code>: Specifies the entry point (start address) for executable files.</li> <li><code>LC_CODE_SIGNATURE</code>: Points to the code signature data.</li> <li><code>LC_SYMTAB</code>: Points to the symbol table and string table (used by linker/debugger).</li> <li><code>LC_DYSYMTAB</code>: Points to dynamic linking symbol information.</li> <li><code>LC_DYLD_INFO_ONLY</code>: Points to optimized dynamic linking info used by <code>dyld</code> (rebasing, binding).</li> </ul>"},{"location":"patching/macho/#path-commands-and-resolution","title":"Path Commands and Resolution","text":"<p>How <code>dyld</code> finds dependent libraries (<code>LC_LOAD_DYLIB</code>) is crucial and often involves special path prefixes:</p> <ul> <li><code>@executable_path</code>: Resolves to the absolute path of the directory containing the main executable of the running process. Useful for finding libraries bundled relative to the main application binary.</li> <li><code>@loader_path</code>: Resolves to the absolute path of the directory containing the specific Mach-O file (executable or library) that contains the <code>LC_LOAD_DYLIB</code> command currently being processed. Useful for libraries finding other libraries located relative to themselves.</li> <li><code>@rpath</code>: A placeholder indicating that <code>dyld</code> should search for the library using a list of runtime search paths. This search list is constructed in order:     -  Paths specified by <code>LC_RPATH</code> load commands within the Mach-O file containing the <code>@rpath</code> dependency itself.     -  Paths specified by <code>LC_RPATH</code> load commands within the main executable (if the dependency is not in the main executable).     -  Paths specified by <code>LC_RPATH</code> load commands within the main executable (if the dependency is not in the main executable).     -  Paths specified in the <code>DYLD_LIBRARY_PATH</code> environment variable (though its use is often restricted for security reasons, especially with System Integrity Protection).     -  Paths specified in the <code>DYLD_FALLBACK_LIBRARY_PATH</code> environment variable (if <code>DYLD_LIBRARY_PATH</code> is not set or doesn't find the library).     -  Standard system fallback locations (e.g., <code>/usr/local/lib</code>, <code>/usr/lib</code>).</li> </ul> <p>The <code>LC_RPATH</code> load command simply contains a path string to be added to this search list.</p>"},{"location":"patching/macho/#how-patching-works-with-arwen-conceptual","title":"How Patching Works with <code>arwen</code> (Conceptual)","text":"<p>Patching Mach-O files with a tool like <code>arwen</code> typically involves modifying the Load Commands or the data they reference (often strings within the commands themselves or in the <code>__LINKEDIT</code> segment).</p> <p>Some common patching operations include:</p> <ul> <li>Modifying runtime dependencies. This involves adding <code>LC_RPATH</code> or removing them. For example, adding <code>LC_RPATH</code> command with the path <code>@loader_path/../Frameworks</code> to make a binary look inside a sibling <code>Frameworks</code> directory for its <code>@rpath</code> dependencies.</li> </ul> <ol> <li>Changing Dependencies:     * Goal: Make a binary look for a library in a different location.     * Action: Modify the path string stored within an <code>LC_LOAD_DYLIB</code> (or <code>LC_LOAD_WEAK_DYLIB</code>) command.     * Example: Change <code>/usr/local/lib/libfoo.dylib</code> to <code>@rpath/libfoo.dylib</code>. This often requires ensuring an appropriate <code>LC_RPATH</code> exists (see below).</li> <li>Changing a Library's Install Name:     * Goal: Change the canonical path by which other binaries refer to this library. Essential when relocating or bundling libraries/frameworks.     * Action: Modify the path string stored within the library's own <code>LC_ID_DYLIB</code> command.     * Example: Change <code>/Users/dev/project/build/lib/libbar.dylib</code> to <code>@rpath/libbar.dylib</code>.</li> <li>Adding or Modifying Runtime Search Paths (RPATH):     * Goal: Tell <code>dyld</code> where to look when resolving <code>@rpath</code> dependencies.     * Action: Add a new <code>LC_RPATH</code> command or modify the path string within an existing one.     * Example: Add an <code>LC_RPATH</code> command with the path <code>@loader_path/../Frameworks</code> to make a binary look inside a sibling <code>Frameworks</code> directory for its <code>@rpath</code> dependencies.</li> </ol> <p>Challenges and Considerations:</p> <ul> <li>Space Constraints: The <code>mach_header</code> specifies the total size (<code>sizeofcmds</code>) allocated for all load commands. If you need to add a new command or make a path string significantly longer, there might not be enough space. Simple tools might fail. More sophisticated tools like <code>arwen</code> might attempt to use existing padding or might need to rewrite parts of the file, which is complex. Changing a path to another path of the same or shorter length is generally safest and easiest.</li> <li>Code Signing: Modifying any part of a signed Mach-O binary (executable or library) invalidates its code signature. On modern macOS and iOS, unsigned or improperly signed code may fail to run due to security policies (Gatekeeper, System Integrity Protection). After patching a signed binary, you must re-sign it using the <code>codesign</code> command-line tool with an appropriate certificate for it to be runnable in many contexts.</li> </ul> <p>Understanding these structures, commands, path resolution rules, and the implications of patching (especially code signing) is vital for successfully using tools like <code>arwen</code> to manage Mach-O binaries.</p>"},{"location":"patching/patching_elf/","title":"Patching an ELF file","text":""},{"location":"patching/patching_elf/#practical-cli-tutorial-patching-an-elf-binary","title":"Practical CLI Tutorial: Patching an ELF Binary","text":"<p>This tutorial demonstrates a common use case for <code>arwen</code>: patching an ELF executable so it can find its required shared library (<code>.so</code> file) using a relative path. This makes the application \"relocatable,\" meaning you can install it in different locations without breaking its ability to find its dependencies.</p> <p>Goal:</p> <p>To modify an application (<code>my_app</code>) that depends on a library (<code>libcustom.so</code>) so that <code>my_app</code> can find <code>libcustom.so</code> when they are placed in a specific directory structure (e.g., <code>bin/</code> and <code>lib/</code> subdirectories within a main installation folder).</p> <p>Scenario:</p> <ol> <li>We have a simple ELF executable named <code>my_app</code>.</li> <li><code>my_app</code> depends on a custom ELF shared library named <code>libcustom.so</code>.</li> <li>Initially, <code>my_app</code> expects <code>libcustom.so</code> to be in a standard system library path (like <code>/usr/lib</code>) or a path listed in <code>LD_LIBRARY_PATH</code>.</li> <li>We want to install the application into <code>/opt/my_app/</code>, placing the executable at <code>/opt/my_app/bin/my_app</code> and the library at <code>/opt/my_app/lib/libcustom.so</code>.</li> <li>We will use <code>arwen</code> to patch <code>/opt/my_app/bin/my_app</code> so it automatically looks for <code>libcustom.so</code> in the adjacent <code>../lib</code> directory.</li> </ol> <p>Prerequisites:</p> <ul> <li>The <code>arwen</code> command-line tool installed and in your PATH.</li> <li>A simple ELF executable (<code>my_app</code>) and an ELF shared library (<code>libcustom.so</code>) it depends on.<ul> <li>Note: For experimentation, you can often use simple existing tools or create minimal examples if you have a C compiler like GCC:<ul> <li><code>libcustom.c</code>: <code>int custom_function() { return 42; }</code></li> <li><code>my_app.c</code>: <code>int custom_function(); int main() { return custom_function(); }</code></li> <li>Compile:<ul> <li><code>gcc -shared -fPIC -o libcustom.so libcustom.c</code></li> <li><code>gcc my_app.c -o my_app -L. -lcustom</code> (Link against the library in the current dir)</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>Step 1: Inspecting the Initial State</p> <p>First, let's see how <code>my_app</code> currently finds (or fails to find) its dependency and what its embedded paths look like. Assume <code>my_app</code> and <code>libcustom.so</code> are in your current directory for now.</p> <pre><code># Check dynamic dependencies using the standard ldd tool\n# note that this command is not available on macos\nldd ./my_app\n</code></pre> <p>You'll likely see output similar to this, indicating libcustom.so is needed but perhaps not found yet in standard locations: <pre><code>        linux-vdso.so.1 (0x...)\n        libcustom.so =&gt; not found  # &lt;--- The problem! Or it might point to /usr/lib if installed there\n        libc.so.6 (0x...) =&gt; /lib/x86_64-linux-gnu/libc.so.6 (...)\n        /lib64/ld-linux-x86-64.so.2 (0x...)\n</code></pre></p> <p>Or you can use <code>arwen</code> to verify the <code>rpaths</code> the ELF file directly:</p> <pre><code>arwen elf print-rpath my_app\n</code></pre> <p>You can see that we have no <code>RPATH</code> set, which means it will not look in any custom directories for <code>libcustom.so</code>.</p> <p>Step 2: Patching the ELF Binary Now, we will patch <code>my_app</code> to add a relative <code>RPATH</code> that points to the <code>lib/</code> directory where <code>libcustom.so</code> will be located.</p> <pre><code>arwen elf set-rpath my_app ../lib\n</code></pre> <p>Step 2: Patching the ELF Binary Now, we will patch <code>my_app</code> to add a relative <code>RPATH</code> that points to the <code>lib/</code> directory where <code>libcustom.so</code> will be located.</p> <pre><code>arwen elf set-rpath my_app ../lib\n</code></pre> <p>If we run <code>arwen elf print-rpath my_app</code> again, we should see the new <code>RPATH</code> set to <code>../lib</code>. <pre><code>arwen elf print-rpath my_app\n</code></pre></p> <pre><code>../lib\n</code></pre> <p>Step 3: Removing the DT_NEEDED Sometimes you might want to remove the <code>DT_NEEDED</code> entry for a library, for example when stripping dependencies.</p> <pre><code>arwen elf remove-needed my_app libcustom.so\n</code></pre> <p>Now, if we check the dependencies again with <code>ldd</code> or <code>arwen</code>, we should see that <code>libcustom.so</code> is no longer listed as a required dependency.</p> <p><pre><code>ldd ./my_app\n</code></pre> or <pre><code>arwen elf print-needed my_app\n</code></pre></p> <p>Conclusion: In this small tutorial, we took a look in a practical example how to use <code>arwen</code> for patching binaries and setup a different <code>RPATH</code> for an ELF binary. This allows the application to find its dependencies in a custom directory structure, making it more portable and easier to deploy.</p>"},{"location":"patching/patching_macho/","title":"Patching an Macho file","text":""},{"location":"patching/patching_macho/#practical-cli-tutorial-patching-a-mach-o-binary","title":"Practical CLI Tutorial: Patching a Mach-O Binary","text":"<p>This tutorial demonstrates a common use case for <code>arwen</code>: patching a Mach-O executable so it can find its required shared library (<code>.dylib</code> file) using a relative path. This makes the application \"relocatable,\" meaning you can install it in different locations without breaking its ability to find its dependencies. This is typically achieved using <code>@rpath</code>.</p> <p>Goal:</p> <p>To modify an application (<code>my_app</code>) that depends on a library (<code>libcustom.dylib</code>) so that <code>my_app</code> can find <code>libcustom.dylib</code> when they are placed in a specific directory structure (e.g., <code>bin/</code> and <code>lib/</code> subdirectories within a main installation folder).</p> <p>Scenario:</p> <ol> <li>We have a simple Mach-O executable named <code>my_app</code>.</li> <li><code>my_app</code> depends on a custom Mach-O shared library named <code>libcustom.dylib</code>.</li> <li>Initially, <code>my_app</code> is compiled to look for <code>libcustom.dylib</code> in a path specified by <code>@rpath</code>, but the application itself does not yet have an <code>rpath</code> configured.</li> <li>We want to install the application into <code>/opt/my_app/</code>, placing the executable at <code>/opt/my_app/bin/my_app</code> and the library at <code>/opt/my_app/lib/libcustom.dylib</code>.</li> <li>We will use <code>arwen</code> to patch <code>/opt/my_app/bin/my_app</code> to add an <code>rpath</code> that tells it to look for <code>libcustom.dylib</code> in the adjacent <code>../lib</code> directory.</li> </ol> <p>Prerequisites:</p> <ul> <li>The <code>arwen</code> command-line tool installed and in your PATH.</li> <li>A simple Mach-O executable (<code>my_app</code>) and a Mach-O shared library (<code>libcustom.dylib</code>) it depends on.<ul> <li>Note: You can create these with a C compiler like <code>clang</code> (standard on macOS):<ul> <li><code>libcustom.c</code>: <code>int custom_function() { return 42; }</code></li> <li><code>my_app.c</code>: <code>int custom_function(); int main() { return custom_function(); }</code></li> <li>Compile:<ul> <li><code>clang -dynamiclib -o libcustom.dylib libcustom.c -install_name \"@rpath/libcustom.dylib\"</code></li> <li><code>clang my_app.c -o my_app -L. -lcustom</code> (Link against the library in the current dir)</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>Step 1: Inspecting the Initial State</p> <p>First, let's see how <code>my_app</code> currently finds its dependency and what its embedded paths look like. Assume <code>my_app</code> and <code>libcustom.dylib</code> are in your current directory.</p> <pre><code># Check dynamic dependencies using the standard otool tool on macOS\notool -L ./my_app\n</code></pre> <p>You'll see output similar to this. Note the <code>@rpath/libcustom.dylib</code> entry. This tells the loader to search for the library in the runtime search paths (rpaths). <pre><code>./my_app:\n    @rpath/libcustom.dylib (compatibility version 0.0.0, current version 0.0.0)\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1319.100.3)\n</code></pre></p> <p>You will see no output, as we have not set any <code>rpath</code> yet. This means the application won't find <code>libcustom.dylib</code> if you try to run it.</p> <p>Step 2: Patching the Mach-O Binary Now, we will patch <code>my_app</code> to add a relative <code>rpath</code> that points to where <code>libcustom.dylib</code> will be located. We use <code>@executable_path</code> which is a special variable that resolves to the directory containing the binary.</p> <pre><code>arwen macho add-rpath my_app @executable_path/../lib\n</code></pre> <p>If we run <code>arwen macho print-rpaths my_app</code> again, we should see the new <code>rpath</code>: <pre><code>arwen macho print-rpaths my_app\n</code></pre></p> <p><pre><code>@executable_path/../lib\n</code></pre> Now, if you were to place <code>my_app</code> in a <code>bin/</code> directory and <code>libcustom.dylib</code> in a sibling <code>lib/</code> directory, the executable would successfully find its library at runtime.</p> <p>Step 3: Removing a Dependency Sometimes you might want to remove a dependency entry from the binary, for example when stripping dependencies.</p> <pre><code>arwen macho remove-dependency my_app libcustom.dylib\n</code></pre> <p>Now, if we check the dependencies again with <code>otool</code>, we should see that <code>libcustom.dylib</code> is no longer listed as a required dependency.</p> <p><pre><code>otool -L ./my_app\n</code></pre> or <pre><code>arwen macho print-dependencies my_app\n</code></pre></p> <p>Conclusion: In this small tutorial, we took a look in a practical example how to use <code>arwen</code> for patching Mach-O binaries and setup a different <code>rpath</code>. This allows the application to find its dependencies in a custom directory structure using <code>@executable_path</code>, making it more portable and easier to deploy on macOS.</p>"},{"location":"reference/cli/arwen/","title":"CLI","text":""},{"location":"reference/cli/arwen/#arwen","title":"<code>arwen</code>","text":""},{"location":"reference/cli/arwen/#about","title":"About","text":"<p>The <code>arwen</code></p>"},{"location":"reference/cli/arwen/#description","title":"Description","text":"<p>The <code>arwen</code> command is the main entry point for the <code>arwen</code> CLI.</p>"},{"location":"reference/cli/arwen/#usage","title":"Usage","text":"<pre><code>arwen &lt;COMMAND&gt;\n</code></pre>"},{"location":"reference/cli/arwen/#subcommands","title":"Subcommands","text":"Command Description <code>macho</code> Mach-O commands <code>elf</code> ELF commands"},{"location":"reference/cli/arwen_extender/","title":"Arwen extender","text":""},{"location":"reference/cli/arwen_extender/#description","title":"Description","text":"<p>The <code>arwen</code> command is the main entry point for the <code>arwen</code> CLI.</p>"},{"location":"reference/cli/arwen/elf/","title":"Elf","text":""},{"location":"reference/cli/arwen/elf/#arwen-elf","title":"<code>arwen elf</code>","text":""},{"location":"reference/cli/arwen/elf/#about","title":"About","text":"<p>ELF commands</p>"},{"location":"reference/cli/arwen/elf/#usage","title":"Usage","text":"<pre><code>arwen elf &lt;COMMAND&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/#subcommands","title":"Subcommands","text":"Command Description <code>add-rpath</code> Add a run path to the elf file <code>remove-rpath</code> Remove runpath from the elf file <code>set-rpath</code> Set the rpath of the elf file <code>print-rpath</code> Print the rpath of the ELF file <code>force-rpath</code> Force usage of <code>DT_RPATH</code> instead of <code>DT_RUNPATH</code> <code>set-interpreter</code> Set the interpreter of the elf file <code>print-interpreter</code> Print the interpreter of the ELF file <code>set-os-abi</code> Change the OS ABI of the elf file <code>print-os-abi</code> Print the OS ABI of the elf file <code>set-soname</code> Sets the DT_SONAME field in the ELF file <code>print-soname</code> Print the <code>DT_SONAME</code> <code>shrink-rpath</code> Remove from the DT_RUNPATH or DT_RPATH all directories that do not contain a library referenced by DT_NEEDED fields of the executable or library <code>add-needed</code> Add dependencies on a dynamic library  DT_NEEDED <code>remove-needed</code> Remove dynamic library dependencies from DT_NEEDED <code>replace-needed</code> Replace dependencies from DT_NEEDED <code>print-needed</code> Print the DT_NEEDED <code>no-default-lib</code> Disable the default library search paths in the elf file <code>clear-symbol-version</code> Clear a version for a specific symbol <code>rename-dynamic-symbols</code> Renames dynamic symbols <code>add-debug-tag</code> Adds <code>DT_DEBUG</code> tag to the elf file to enable debugging <code>clear-exec-stack</code> Clears the executable flag of the GNU_STACK program header <code>set-exec-stack</code> Set the executable flag of the GNU_STACK program header <code>print-exec-stack</code> Print the exec stack of the ELF file"},{"location":"reference/cli/arwen/macho/","title":"Macho","text":""},{"location":"reference/cli/arwen/macho/#arwen-macho","title":"<code>arwen macho</code>","text":""},{"location":"reference/cli/arwen/macho/#about","title":"About","text":"<p>Mach-O commands</p>"},{"location":"reference/cli/arwen/macho/#usage","title":"Usage","text":"<pre><code>arwen macho &lt;COMMAND&gt;\n</code></pre>"},{"location":"reference/cli/arwen/macho/#subcommands","title":"Subcommands","text":"Command Description <code>delete-rpath</code> Remove a run path <code>change-rpath</code> Change already existing run path <code>add-rpath</code> Add a run path <code>change-install-name</code> Change existing dylib load name <code>change-install-id</code> Change dylib id. Works only if your object is a shared library"},{"location":"reference/cli/arwen/elf/add-debug-tag/","title":"Add debug tag","text":""},{"location":"reference/cli/arwen/elf/add-debug-tag/#arwen-elf-add-debug-tag","title":"<code>arwen elf add-debug-tag</code>","text":""},{"location":"reference/cli/arwen/elf/add-debug-tag/#about","title":"About","text":"<p>Adds <code>DT_DEBUG</code> tag to the elf file to enable debugging</p>"},{"location":"reference/cli/arwen/elf/add-debug-tag/#usage","title":"Usage","text":"<pre><code>arwen elf add-debug-tag &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/add-debug-tag/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/add-needed/","title":"Add needed","text":""},{"location":"reference/cli/arwen/elf/add-needed/#arwen-elf-add-needed","title":"<code>arwen elf add-needed</code>","text":""},{"location":"reference/cli/arwen/elf/add-needed/#about","title":"About","text":"<p>Add dependencies on a dynamic library  DT_NEEDED</p>"},{"location":"reference/cli/arwen/elf/add-needed/#usage","title":"Usage","text":"<pre><code>arwen elf add-needed &lt;PATH_TO_BINARY&gt; [DT_NEEDED]...\n</code></pre>"},{"location":"reference/cli/arwen/elf/add-needed/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> <li> <code>&lt;DT_NEEDED&gt;</code> New DT_NEEDED to add May be provided more than once. </li> </ul>"},{"location":"reference/cli/arwen/elf/add-rpath/","title":"Add rpath","text":""},{"location":"reference/cli/arwen/elf/add-rpath/#arwen-elf-add-rpath","title":"<code>arwen elf add-rpath</code>","text":""},{"location":"reference/cli/arwen/elf/add-rpath/#about","title":"About","text":"<p>Add a run path to the elf file</p>"},{"location":"reference/cli/arwen/elf/add-rpath/#usage","title":"Usage","text":"<pre><code>arwen elf add-rpath &lt;NEW_RPATH&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/add-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;NEW_RPATH&gt;</code> New rpath to add required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/clear-exec-stack/","title":"Clear exec stack","text":""},{"location":"reference/cli/arwen/elf/clear-exec-stack/#arwen-elf-clear-exec-stack","title":"<code>arwen elf clear-exec-stack</code>","text":""},{"location":"reference/cli/arwen/elf/clear-exec-stack/#about","title":"About","text":"<p>Clears the executable flag of the GNU_STACK program header</p>"},{"location":"reference/cli/arwen/elf/clear-exec-stack/#usage","title":"Usage","text":"<pre><code>arwen elf clear-exec-stack &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/clear-exec-stack/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/clear-symbol-version/","title":"Clear symbol version","text":""},{"location":"reference/cli/arwen/elf/clear-symbol-version/#arwen-elf-clear-symbol-version","title":"<code>arwen elf clear-symbol-version</code>","text":""},{"location":"reference/cli/arwen/elf/clear-symbol-version/#about","title":"About","text":"<p>Clear a version for a specific symbol</p>"},{"location":"reference/cli/arwen/elf/clear-symbol-version/#usage","title":"Usage","text":"<pre><code>arwen elf clear-symbol-version &lt;SYMBOL&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/clear-symbol-version/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;SYMBOL&gt;</code> Symbol to clear the version for required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/force-rpath/","title":"Force rpath","text":""},{"location":"reference/cli/arwen/elf/force-rpath/#arwen-elf-force-rpath","title":"<code>arwen elf force-rpath</code>","text":""},{"location":"reference/cli/arwen/elf/force-rpath/#about","title":"About","text":"<p>Force usage of <code>DT_RPATH</code> instead of <code>DT_RUNPATH</code></p>"},{"location":"reference/cli/arwen/elf/force-rpath/#usage","title":"Usage","text":"<pre><code>arwen elf force-rpath &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/force-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/no-default-lib/","title":"No default lib","text":""},{"location":"reference/cli/arwen/elf/no-default-lib/#arwen-elf-no-default-lib","title":"<code>arwen elf no-default-lib</code>","text":""},{"location":"reference/cli/arwen/elf/no-default-lib/#about","title":"About","text":"<p>Disable the default library search paths in the elf file</p>"},{"location":"reference/cli/arwen/elf/no-default-lib/#usage","title":"Usage","text":"<pre><code>arwen elf no-default-lib &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/no-default-lib/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/print-exec-stack/","title":"Print exec stack","text":""},{"location":"reference/cli/arwen/elf/print-exec-stack/#arwen-elf-print-exec-stack","title":"<code>arwen elf print-exec-stack</code>","text":""},{"location":"reference/cli/arwen/elf/print-exec-stack/#about","title":"About","text":"<p>Print the exec stack of the ELF file</p>"},{"location":"reference/cli/arwen/elf/print-exec-stack/#usage","title":"Usage","text":"<pre><code>arwen elf print-exec-stack &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/print-exec-stack/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/print-interpreter/","title":"Print interpreter","text":""},{"location":"reference/cli/arwen/elf/print-interpreter/#arwen-elf-print-interpreter","title":"<code>arwen elf print-interpreter</code>","text":""},{"location":"reference/cli/arwen/elf/print-interpreter/#about","title":"About","text":"<p>Print the interpreter of the ELF file</p>"},{"location":"reference/cli/arwen/elf/print-interpreter/#usage","title":"Usage","text":"<pre><code>arwen elf print-interpreter &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/print-interpreter/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/print-needed/","title":"Print needed","text":""},{"location":"reference/cli/arwen/elf/print-needed/#arwen-elf-print-needed","title":"<code>arwen elf print-needed</code>","text":""},{"location":"reference/cli/arwen/elf/print-needed/#about","title":"About","text":"<p>Print the DT_NEEDED</p>"},{"location":"reference/cli/arwen/elf/print-needed/#usage","title":"Usage","text":"<pre><code>arwen elf print-needed &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/print-needed/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/print-os-abi/","title":"Print os abi","text":""},{"location":"reference/cli/arwen/elf/print-os-abi/#arwen-elf-print-os-abi","title":"<code>arwen elf print-os-abi</code>","text":""},{"location":"reference/cli/arwen/elf/print-os-abi/#about","title":"About","text":"<p>Print the OS ABI of the elf file</p>"},{"location":"reference/cli/arwen/elf/print-os-abi/#usage","title":"Usage","text":"<pre><code>arwen elf print-os-abi &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/print-os-abi/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/print-rpath/","title":"Print rpath","text":""},{"location":"reference/cli/arwen/elf/print-rpath/#arwen-elf-print-rpath","title":"<code>arwen elf print-rpath</code>","text":""},{"location":"reference/cli/arwen/elf/print-rpath/#about","title":"About","text":"<p>Print the rpath of the ELF file</p>"},{"location":"reference/cli/arwen/elf/print-rpath/#usage","title":"Usage","text":"<pre><code>arwen elf print-rpath &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/print-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/print-soname/","title":"Print soname","text":""},{"location":"reference/cli/arwen/elf/print-soname/#arwen-elf-print-soname","title":"<code>arwen elf print-soname</code>","text":""},{"location":"reference/cli/arwen/elf/print-soname/#about","title":"About","text":"<p>Print the <code>DT_SONAME</code></p>"},{"location":"reference/cli/arwen/elf/print-soname/#usage","title":"Usage","text":"<pre><code>arwen elf print-soname &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/print-soname/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/remove-needed/","title":"Remove needed","text":""},{"location":"reference/cli/arwen/elf/remove-needed/#arwen-elf-remove-needed","title":"<code>arwen elf remove-needed</code>","text":""},{"location":"reference/cli/arwen/elf/remove-needed/#about","title":"About","text":"<p>Remove dynamic library dependencies from DT_NEEDED</p>"},{"location":"reference/cli/arwen/elf/remove-needed/#usage","title":"Usage","text":"<pre><code>arwen elf remove-needed &lt;PATH_TO_BINARY&gt; [DT_NEEDED]...\n</code></pre>"},{"location":"reference/cli/arwen/elf/remove-needed/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> <li> <code>&lt;DT_NEEDED&gt;</code> New DT_NEEDED to remove May be provided more than once. </li> </ul>"},{"location":"reference/cli/arwen/elf/remove-rpath/","title":"Remove rpath","text":""},{"location":"reference/cli/arwen/elf/remove-rpath/#arwen-elf-remove-rpath","title":"<code>arwen elf remove-rpath</code>","text":""},{"location":"reference/cli/arwen/elf/remove-rpath/#about","title":"About","text":"<p>Remove runpath from the elf file</p>"},{"location":"reference/cli/arwen/elf/remove-rpath/#usage","title":"Usage","text":"<pre><code>arwen elf remove-rpath &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/remove-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/rename-dynamic-symbols/","title":"Rename dynamic symbols","text":""},{"location":"reference/cli/arwen/elf/rename-dynamic-symbols/#arwen-elf-rename-dynamic-symbols","title":"<code>arwen elf rename-dynamic-symbols</code>","text":""},{"location":"reference/cli/arwen/elf/rename-dynamic-symbols/#about","title":"About","text":"<p>Renames dynamic symbols</p>"},{"location":"reference/cli/arwen/elf/rename-dynamic-symbols/#usage","title":"Usage","text":"<pre><code>arwen elf rename-dynamic-symbols &lt;PATH_TO_BINARY&gt; [RENAME_SYMBOLS]...\n</code></pre>"},{"location":"reference/cli/arwen/elf/rename-dynamic-symbols/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> <li><code>&lt;RENAME_SYMBOLS&gt;</code> : May be provided more than once.</li> </ul>"},{"location":"reference/cli/arwen/elf/replace-needed/","title":"Replace needed","text":""},{"location":"reference/cli/arwen/elf/replace-needed/#arwen-elf-replace-needed","title":"<code>arwen elf replace-needed</code>","text":""},{"location":"reference/cli/arwen/elf/replace-needed/#about","title":"About","text":"<p>Replace dependencies from DT_NEEDED</p>"},{"location":"reference/cli/arwen/elf/replace-needed/#usage","title":"Usage","text":"<pre><code>arwen elf replace-needed &lt;PATH_TO_BINARY&gt; [DT_NEEDED]...\n</code></pre>"},{"location":"reference/cli/arwen/elf/replace-needed/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> <li><code>&lt;DT_NEEDED&gt;</code> : May be provided more than once.</li> </ul>"},{"location":"reference/cli/arwen/elf/set-exec-stack/","title":"Set exec stack","text":""},{"location":"reference/cli/arwen/elf/set-exec-stack/#arwen-elf-set-exec-stack","title":"<code>arwen elf set-exec-stack</code>","text":""},{"location":"reference/cli/arwen/elf/set-exec-stack/#about","title":"About","text":"<p>Set the executable flag of the GNU_STACK program header</p>"},{"location":"reference/cli/arwen/elf/set-exec-stack/#usage","title":"Usage","text":"<pre><code>arwen elf set-exec-stack &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/set-exec-stack/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/set-interpreter/","title":"Set interpreter","text":""},{"location":"reference/cli/arwen/elf/set-interpreter/#arwen-elf-set-interpreter","title":"<code>arwen elf set-interpreter</code>","text":""},{"location":"reference/cli/arwen/elf/set-interpreter/#about","title":"About","text":"<p>Set the interpreter of the elf file</p>"},{"location":"reference/cli/arwen/elf/set-interpreter/#usage","title":"Usage","text":"<pre><code>arwen elf set-interpreter &lt;INTERPRETER&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/set-interpreter/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;INTERPRETER&gt;</code> Interpreter to set required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/set-os-abi/","title":"Set os abi","text":""},{"location":"reference/cli/arwen/elf/set-os-abi/#arwen-elf-set-os-abi","title":"<code>arwen elf set-os-abi</code>","text":""},{"location":"reference/cli/arwen/elf/set-os-abi/#about","title":"About","text":"<p>Change the OS ABI of the elf file</p>"},{"location":"reference/cli/arwen/elf/set-os-abi/#usage","title":"Usage","text":"<pre><code>arwen elf set-os-abi &lt;OS_ABI&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/set-os-abi/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;OS_ABI&gt;</code> Interpreter to set required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/set-rpath/","title":"Set rpath","text":""},{"location":"reference/cli/arwen/elf/set-rpath/#arwen-elf-set-rpath","title":"<code>arwen elf set-rpath</code>","text":""},{"location":"reference/cli/arwen/elf/set-rpath/#about","title":"About","text":"<p>Set the rpath of the elf file</p>"},{"location":"reference/cli/arwen/elf/set-rpath/#usage","title":"Usage","text":"<pre><code>arwen elf set-rpath &lt;NEW_RPATH&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/set-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;NEW_RPATH&gt;</code> New rpath to add required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/set-soname/","title":"Set soname","text":""},{"location":"reference/cli/arwen/elf/set-soname/#arwen-elf-set-soname","title":"<code>arwen elf set-soname</code>","text":""},{"location":"reference/cli/arwen/elf/set-soname/#about","title":"About","text":"<p>Sets the DT_SONAME field in the ELF file</p>"},{"location":"reference/cli/arwen/elf/set-soname/#usage","title":"Usage","text":"<pre><code>arwen elf set-soname &lt;SONAME&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/set-soname/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;SONAME&gt;</code> SONAME to set required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/shrink-rpath/","title":"Shrink rpath","text":""},{"location":"reference/cli/arwen/elf/shrink-rpath/#arwen-elf-shrink-rpath","title":"<code>arwen elf shrink-rpath</code>","text":""},{"location":"reference/cli/arwen/elf/shrink-rpath/#about","title":"About","text":"<p>Remove from the DT_RUNPATH or DT_RPATH all directories that do not contain a library referenced by DT_NEEDED fields of the executable or library</p>"},{"location":"reference/cli/arwen/elf/shrink-rpath/#usage","title":"Usage","text":"<pre><code>arwen elf shrink-rpath [OPTIONS] &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/elf/shrink-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/elf/shrink-rpath/#options","title":"Options","text":"<ul> <li> <code>--allowed-rpath-prefixes (-a) &lt;ALLOWED_RPATH_PREFIXES&gt;</code> option to allow rpath prefixes May be provided more than once. </li> </ul>"},{"location":"reference/cli/arwen/macho/add-rpath/","title":"Add rpath","text":""},{"location":"reference/cli/arwen/macho/add-rpath/#arwen-macho-add-rpath","title":"<code>arwen macho add-rpath</code>","text":""},{"location":"reference/cli/arwen/macho/add-rpath/#about","title":"About","text":"<p>Add a run path</p>"},{"location":"reference/cli/arwen/macho/add-rpath/#usage","title":"Usage","text":"<pre><code>arwen macho add-rpath &lt;NEW_RPATH&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/macho/add-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;NEW_RPATH&gt;</code> New rpath to add required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/macho/change-install-id/","title":"Change install id","text":""},{"location":"reference/cli/arwen/macho/change-install-id/#arwen-macho-change-install-id","title":"<code>arwen macho change-install-id</code>","text":""},{"location":"reference/cli/arwen/macho/change-install-id/#about","title":"About","text":"<p>Change dylib id. Works only if your object is a shared library</p>"},{"location":"reference/cli/arwen/macho/change-install-id/#usage","title":"Usage","text":"<pre><code>arwen macho change-install-id &lt;NEW_INSTALL_ID&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/macho/change-install-id/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;NEW_INSTALL_ID&gt;</code> New rpath to add required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/macho/change-install-name/","title":"Change install name","text":""},{"location":"reference/cli/arwen/macho/change-install-name/#arwen-macho-change-install-name","title":"<code>arwen macho change-install-name</code>","text":""},{"location":"reference/cli/arwen/macho/change-install-name/#about","title":"About","text":"<p>Change existing dylib load name</p>"},{"location":"reference/cli/arwen/macho/change-install-name/#usage","title":"Usage","text":"<pre><code>arwen macho change-install-name &lt;OLD_INSTALL_NAME&gt; &lt;NEW_INSTALL_NAME&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/macho/change-install-name/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;OLD_INSTALL_NAME&gt;</code> Old rpath to remove required: <code>true</code> </li> <li> <code>&lt;NEW_INSTALL_NAME&gt;</code> New rpath to add required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/macho/change-rpath/","title":"Change rpath","text":""},{"location":"reference/cli/arwen/macho/change-rpath/#arwen-macho-change-rpath","title":"<code>arwen macho change-rpath</code>","text":""},{"location":"reference/cli/arwen/macho/change-rpath/#about","title":"About","text":"<p>Change already existing run path</p>"},{"location":"reference/cli/arwen/macho/change-rpath/#usage","title":"Usage","text":"<pre><code>arwen macho change-rpath &lt;OLD_RPATH&gt; &lt;NEW_RPATH&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/macho/change-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;OLD_RPATH&gt;</code> Old rpath to remove required: <code>true</code> </li> <li> <code>&lt;NEW_RPATH&gt;</code> New rpath to add required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"},{"location":"reference/cli/arwen/macho/delete-rpath/","title":"Delete rpath","text":""},{"location":"reference/cli/arwen/macho/delete-rpath/#arwen-macho-delete-rpath","title":"<code>arwen macho delete-rpath</code>","text":""},{"location":"reference/cli/arwen/macho/delete-rpath/#about","title":"About","text":"<p>Remove a run path</p>"},{"location":"reference/cli/arwen/macho/delete-rpath/#usage","title":"Usage","text":"<pre><code>arwen macho delete-rpath &lt;RPATH_TO_REMOVE&gt; &lt;PATH_TO_BINARY&gt;\n</code></pre>"},{"location":"reference/cli/arwen/macho/delete-rpath/#arguments","title":"Arguments","text":"<ul> <li> <code>&lt;RPATH_TO_REMOVE&gt;</code> Rpath to remove required: <code>true</code> </li> <li> <code>&lt;PATH_TO_BINARY&gt;</code> Path to the file to change required: <code>true</code> </li> </ul>"}]}